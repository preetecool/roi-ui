{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "background",
  "type": "registry:item",
  "title": "Background",
  "description": "A background component with various visual effects.",
  "files": [
    {
      "path": "registry/brook/ui/background/background.tsx",
      "content": "\"use client\";\nimport React, { useEffect, useRef } from \"react\";\nimport styles from \"./background.module.css\";\n\nconst vertexShader = `\n  attribute vec2 a_position;\n  varying vec2 v_uv;\n\n  void main() {\n    v_uv = a_position * 0.5 + 0.5;\n    gl_Position = vec4(a_position, 0.0, 1.0);\n  }\n`;\n\nconst fragmentShader = `\n  precision highp float;\n\n  uniform float u_time;\n  uniform vec2 u_resolution;\n\n  uniform vec3 u_primaryColor;\n  uniform vec3 u_secondaryColor;\n  uniform vec3 u_backgroundColor;\n  uniform float u_backgroundOpacity;\n\n  // Animation uniforms\n  uniform float u_animationSpeed;\n  uniform float u_noiseScale;\n  uniform float u_intensity;\n\n  uniform float u_octaves;\n  uniform float u_warpStrength;\n  varying vec2 v_uv;\n\n  vec3 permute(vec3 x) {\n      return mod(((x*34.0)+1.0)*x, 289.0);\n  }\n\n  float snoise(vec2 v) {\n      const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);\n      vec2 i  = floor(v + dot(v, C.yy));\n      vec2 x0 = v -   i + dot(i, C.xx);\n      vec2 i1;\n      i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n      vec4 x12 = x0.xyxy + C.xxzz;\n      x12.xy -= i1;\n      i = mod(i, 289.0);\n      vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0 ));\n      vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n      m = m*m;\n      m = m*m;\n      vec3 x = 2.0 * fract(p * C.www) - 1.0;\n      vec3 h = abs(x) - 0.5;\n      vec3 ox = floor(x + 0.5);\n      vec3 a0 = x - ox;\n      m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);\n      vec3 g;\n      g.x  = a0.x  * x0.x  + h.x  * x0.y;\n      g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n      return 130.0 * dot(m, g);\n  }\n\n  float fbm(vec2 pos, int octaves) {\n      float value = 0.0;\n      float amplitude = 0.5;\n      float frequency = 1.0;\n\n      for (int i = 0; i < 6; i++) {\n          if (i >= octaves) break;\n          value += amplitude * snoise(pos * frequency);\n          amplitude *= 0.5;\n          frequency *= 2.0;\n      }\n\n      return value;\n  }\n\n  float domainWarp(vec2 pos, float time) {\n      vec2 q = vec2(\n          fbm(pos + vec2(0.0, 0.0), int(u_octaves)),\n          fbm(pos + vec2(5.2, 1.3), int(u_octaves))\n      );\n\n      vec2 r = vec2(\n          fbm(pos + u_warpStrength*q + vec2(1.7, 9.2) + 0.15*time, int(u_octaves-1.0)),\n          fbm(pos + u_warpStrength*q + vec2(8.3, 2.8) + 0.126*time, int(u_octaves-1.0))\n      );\n\n      return fbm(pos + u_warpStrength*r, int(u_octaves-2.0));\n  }\n\n  vec3 palette(float t) {\n      vec3 a = u_primaryColor;\n      vec3 b = u_secondaryColor;\n      vec3 c = mix(u_primaryColor, u_secondaryColor, 0.6);\n      vec3 d = mix(u_primaryColor, u_secondaryColor, 0.7);\n\n      d = mix(d, u_secondaryColor * 0.5, sin(t * 1.5) * 0.4 + 0.5);\n      d = mix(d, u_primaryColor * 1.2, sin(t * 2.2) * 0.3 + 0.5);\n\n      float wave = cos(6.28318 * (c.x * t + d.x)) * 0.6;\n      vec3 result = a + b * wave * 0.8;\n\n      return result;\n  }\n\n\n  void main() {\n      vec2 uv = v_uv;\n      vec2 st = uv * u_noiseScale;\n\n      float time = u_time * u_animationSpeed;\n\n      vec2 animPos = st + vec2(time * 0.1, time * 0.05);\n\n      float noise1 = domainWarp(animPos, time);\n\n      vec2 animPos2 = st * 1.5 + vec2(-time * 0.08, time * 0.12);\n      float noise2 = fbm(animPos2, int(u_octaves-1.0));\n\n      vec2 animPos3 = st * 2.5 + vec2(time * 0.06, -time * 0.04);\n      float noise3 = snoise(animPos3);\n\n      float combinedNoise = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;\n\n      float pattern = smoothstep(-0.3, 0.5, combinedNoise);\n\n      float colorShift = time * 0.2 + uv.x * 0.4;\n      colorShift += noise1 * 0.3;\n      vec3 color = palette(colorShift);\n\n      vec3 bgNoise = vec3(snoise(uv * 2.0 + time * 0.1) * 0.02);\n      vec3 bgColor = u_backgroundColor + bgNoise;\n\n      float intensity = pattern * u_intensity;\n      color = mix(bgColor, color, intensity);\n\n      vec3 bgMovement = vec3(snoise(uv * 5.0 + time * 0.15) * 0.02);\n      color += bgMovement;\n\n      gl_FragColor = vec4(color, u_backgroundOpacity);\n  }\n`;\n\ninterface BackgroundProps {\n  className?: string;\n  primaryColor?: [number, number, number];\n  secondaryColor?: [number, number, number];\n  backgroundColor?: [number, number, number];\n  backgroundOpacity?: number;\n  animationSpeed?: number;\n  noiseScale?: number;\n  intensity?: number;\n  octaves?: number;\n  warpStrength?: number;\n}\n\nconst Background: React.FC<BackgroundProps> = ({\n  className,\n  primaryColor = [0.85, 0.85, 0.85],\n  secondaryColor = [0.25, 0.25, 0.25],\n  backgroundColor = [0.0, 0.0, 0.0],\n  backgroundOpacity = 0.0,\n  animationSpeed = 0.3,\n  noiseScale = 3.0,\n  intensity = 0.9,\n  octaves = 4,\n  warpStrength = 4.0,\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const animationRef = useRef<number>(0);\n  const startTimeRef = useRef<number>(0);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const gl = canvas.getContext(\"webgl\");\n    if (!gl) {\n      console.error(\"WebGL not supported\");\n      return;\n    }\n\n    // Set canvas size\n    const setCanvasSize = () => {\n      canvas.width = window.innerWidth;\n      canvas.height = window.innerHeight;\n      gl.viewport(0, 0, canvas.width, canvas.height);\n    };\n\n    setCanvasSize();\n    window.addEventListener(\"resize\", setCanvasSize);\n\n    // Create shaders\n    const createShader = (type: number, source: string) => {\n      const shader = gl.createShader(type);\n      if (!shader) return null;\n\n      gl.shaderSource(shader, source);\n      gl.compileShader(shader);\n\n      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        console.error(\"Shader compile error:\", gl.getShaderInfoLog(shader));\n        gl.deleteShader(shader);\n        return null;\n      }\n\n      return shader;\n    };\n\n    const vertShader = createShader(gl.VERTEX_SHADER, vertexShader);\n    const fragShader = createShader(gl.FRAGMENT_SHADER, fragmentShader);\n\n    if (!vertShader || !fragShader) return;\n\n    // Create program\n    const program = gl.createProgram();\n    if (!program) return;\n\n    gl.attachShader(program, vertShader);\n    gl.attachShader(program, fragShader);\n    gl.linkProgram(program);\n\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      console.error(\"Program link error:\", gl.getProgramInfoLog(program));\n      return;\n    }\n\n    // Set up geometry\n    const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);\n\n    const buffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n\n    const positionLocation = gl.getAttribLocation(program, \"a_position\");\n    gl.enableVertexAttribArray(positionLocation);\n    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n\n    // Get uniform locations\n    const timeLocation = gl.getUniformLocation(program, \"u_time\");\n    const resolutionLocation = gl.getUniformLocation(program, \"u_resolution\");\n\n    const primaryColorLocation = gl.getUniformLocation(program, \"u_primaryColor\");\n    const secondaryColorLocation = gl.getUniformLocation(program, \"u_secondaryColor\");\n    const backgroundColorLocation = gl.getUniformLocation(program, \"u_backgroundColor\");\n    const backgroundOpacityLocation = gl.getUniformLocation(program, \"u_backgroundOpacity\");\n\n    const animationSpeedLocation = gl.getUniformLocation(program, \"u_animationSpeed\");\n    const noiseScaleLocation = gl.getUniformLocation(program, \"u_noiseScale\");\n    const intensityLocation = gl.getUniformLocation(program, \"u_intensity\");\n\n    const octavesLocation = gl.getUniformLocation(program, \"u_octaves\");\n    const warpStrengthLocation = gl.getUniformLocation(program, \"u_warpStrength\");\n\n    const render = (time: number) => {\n      if (!startTimeRef.current) startTimeRef.current = time;\n      const elapsedTime = (time - startTimeRef.current) * 0.001;\n\n      gl.useProgram(program);\n\n      gl.uniform1f(timeLocation, elapsedTime);\n      gl.uniform2f(resolutionLocation, canvas.width, canvas.height);\n\n      gl.uniform3f(primaryColorLocation, primaryColor[0], primaryColor[1], primaryColor[2]);\n      gl.uniform3f(secondaryColorLocation, secondaryColor[0], secondaryColor[1], secondaryColor[2]);\n      gl.uniform3f(backgroundColorLocation, backgroundColor[0], backgroundColor[1], backgroundColor[2]);\n      gl.uniform1f(backgroundOpacityLocation, backgroundOpacity);\n\n      gl.uniform1f(animationSpeedLocation, animationSpeed);\n      gl.uniform1f(noiseScaleLocation, noiseScale);\n      gl.uniform1f(intensityLocation, intensity);\n\n      gl.uniform1f(octavesLocation, octaves);\n      gl.uniform1f(warpStrengthLocation, warpStrength);\n\n      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n\n      animationRef.current = requestAnimationFrame(render);\n    };\n\n    render(0);\n\n    return () => {\n      window.removeEventListener(\"resize\", setCanvasSize);\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current);\n      }\n    };\n  }, [\n    primaryColor,\n    secondaryColor,\n    backgroundColor,\n    backgroundOpacity,\n    animationSpeed,\n    noiseScale,\n    intensity,\n    octaves,\n    warpStrength,\n  ]);\n\n  return (\n    <div className={`${styles.backgroundContainer} ${className || \"\"}`}>\n      <canvas ref={canvasRef} className={styles.canvas} />\n    </div>\n  );\n};\n\nexport default Background;\n",
      "type": "registry:file",
      "target": "~/components/ui/background/background.tsx"
    },
    {
      "path": "registry/brook/ui/background/background.module.css",
      "content": ".backgroundContainer {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  border-radius: var(--radius);\n}\n\n.canvas {\n  display: block;\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n}\n",
      "type": "registry:file",
      "target": "~/components/ui/background/background.module.css"
    }
  ]
}