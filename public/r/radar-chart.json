{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "radar-chart",
  "type": "registry:item",
  "title": "Radar Chart",
  "description": "Multi-dimensional radar charts for comparing multiple variables across categories.",
  "dependencies": [
    "@visx/group",
    "@visx/scale",
    "@visx/point",
    "@visx/shape",
    "@visx/tooltip",
    "@visx/event",
    "@visx/gradient",
    "@visx/responsive"
  ],
  "files": [
    {
      "path": "registry/brook/ui/charts/chart-tooltip.tsx",
      "content": "\"use client\";\n\nimport { TooltipWithBounds, defaultStyles } from \"@visx/tooltip\";\n\ntype NumberValue = number | { valueOf(): number };\n\nexport interface ChartDataItem {\n  type: string;\n  [key: string]: unknown;\n}\n\nexport interface ChartTooltipProps<T extends ChartDataItem> {\n  tooltipData: T[];\n  tooltipLeft: number;\n  tooltipTop: number;\n  uniqueTypes: string[];\n  colors: string[];\n  getRD: (d: T) => number;\n  getDate: (d: T) => NumberValue | string;\n  dateFormatter?: (value: NumberValue | string) => string;\n}\n\nexport default function ChartTooltip<T extends ChartDataItem>({\n  tooltipData,\n  tooltipLeft,\n  tooltipTop,\n  uniqueTypes,\n  colors,\n  getRD,\n  getDate,\n  dateFormatter,\n}: ChartTooltipProps<T>) {\n  const tooltipStyles = {\n    ...defaultStyles,\n    minWidth: 50,\n    backgroundColor: \"var(--background)\",\n\n    color: \"var(--foreground)\",\n    borderRadius: \"var(--radius)\",\n    padding: \"8px\",\n    fontSize: \"12px\",\n    transition: \"all 200ms linear\",\n  };\n\n  return (\n    <TooltipWithBounds top={tooltipTop} left={tooltipLeft} style={tooltipStyles} offsetLeft={15} offsetTop={-10}>\n      <p style={{ marginBottom: \"6px\", fontSize: \"11px\", fontWeight: \"500\" }}>\n        {dateFormatter ? dateFormatter(getDate(tooltipData[0])) : String(getDate(tooltipData[0]))}\n      </p>\n      {tooltipData.map((d, i) => (\n        <div\n          key={i}\n          style={{\n            display: \"flex\",\n            alignItems: \"center\",\n            justifyContent: \"space-between\",\n            marginBottom: \"4px\",\n            gap: \"12px\",\n          }}\n        >\n          <div style={{ display: \"flex\", alignItems: \"center\", gap: \"4px\" }}>\n            <div\n              style={{\n                width: \"6px\",\n                height: \"6px\",\n                backgroundColor: colors[uniqueTypes.indexOf(d.type)],\n                borderRadius: \"50%\",\n              }}\n            />\n            <span style={{ fontSize: \"11px\", color: \"var(--muted-foreground)\" }}>\n              {d.type.charAt(0) + d.type.slice(1).toLowerCase()}\n            </span>\n          </div>\n          <span style={{ fontSize: \"11px\", fontFamily: \"monospace\" }}>{getRD(d)}M</span>\n        </div>\n      ))}\n    </TooltipWithBounds>\n  );\n}\n",
      "type": "registry:file",
      "target": "~/components/ui/charts/chart-tooltip.tsx"
    },
    {
      "path": "registry/brook/ui/charts/radar-chart.tsx",
      "content": "\"use client\";\n\nimport { useMemo, useCallback, useId } from \"react\";\nimport { Group } from \"@visx/group\";\nimport { scaleLinear } from \"@visx/scale\";\nimport { useTooltip, TooltipWithBounds, defaultStyles } from \"@visx/tooltip\";\nimport { localPoint } from \"@visx/event\";\nimport { LinearGradient } from \"@visx/gradient\";\nimport { motion } from \"motion/react\";\n\nexport interface RadarChartData {\n  category: string;\n  value: number;\n  type: string;\n}\n\nexport interface Margin {\n  top: number;\n  right: number;\n  bottom: number;\n  left: number;\n}\n\nexport interface RadarChartProps {\n  data: RadarChartData[];\n  width: number;\n  height: number;\n  margin?: Margin;\n  levels?: number;\n  maxValue?: number;\n  showLabels?: boolean;\n  showGrid?: boolean;\n  fillOpacity?: number;\n  animated?: boolean;\n}\n\nconst genAngles = (length: number) =>\n  [...new Array(length + 1)].map((_, i) => ({\n    angle: Math.round(i * (360 / length) * 10000) / 10000,\n  }));\n\nconst genPolygonPoints = (dataArray: RadarChartData[], scale: (n: number) => number) => {\n  const step = (Math.PI * 2) / dataArray.length;\n  const points: string = dataArray\n    .map((v, i) => {\n      const x = Math.round(scale(v.value) * Math.cos(i * step) * 10000) / 10000;\n      const y = Math.round(scale(v.value) * Math.sin(i * step) * 10000) / 10000;\n      return `${x},${y}`;\n    })\n    .join(\" \");\n  return points;\n};\n\nconst genRadialGridPath = (angles: { angle: number }[], radius: number) => {\n  const points = angles.map((angle) => {\n    const radians = (angle.angle * Math.PI) / 180;\n    const x = Math.round(radius * Math.cos(radians) * 10000) / 10000;\n    const y = Math.round(radius * Math.sin(radians) * 10000) / 10000;\n    return `${x},${y}`;\n  });\n\n  if (points.length === 0) return \"\";\n\n  const firstPoint = points[0];\n  return `M${firstPoint}L${points.slice(1).join(\"L\")}Z`;\n};\n\nfunction RadarChart({\n  data,\n  width,\n  height,\n  margin = { top: 40, right: 40, bottom: 40, left: 40 },\n  levels = 5,\n  maxValue,\n  showLabels = true,\n  showGrid = true,\n  fillOpacity = 0.3,\n  animated = false,\n}: RadarChartProps) {\n  const { tooltipData, tooltipLeft = 0, tooltipTop = 0, showTooltip, hideTooltip } = useTooltip<RadarChartData>();\n  const gradientId = useId();\n\n  const centerX = width / 2;\n  const centerY = height / 2;\n  const radius = Math.min(centerX - margin.left, centerY - margin.top);\n\n  const maxVal = maxValue || Math.max(...data.map((d) => d.value));\n\n  const radiusScale = scaleLinear({\n    domain: [0, maxVal],\n    range: [0, radius],\n  });\n\n  const angles = genAngles(data.length);\n  const polygonPoints = genPolygonPoints(data, radiusScale);\n\n  const points = useMemo(() => {\n    const step = (Math.PI * 2) / data.length;\n    return data.map((d, i) => {\n      const angle = i * step;\n      const r = radiusScale(d.value);\n      return {\n        ...d,\n        x: Math.round((centerX + r * Math.cos(angle)) * 10000) / 10000,\n        y: Math.round((centerY + r * Math.sin(angle)) * 10000) / 10000,\n        angle,\n        radius: r,\n      };\n    });\n  }, [data, radiusScale, centerX, centerY]);\n\n  const handleTooltip = useCallback(\n    (event: React.MouseEvent, datum: RadarChartData) => {\n      const { x, y } = localPoint(event) || { x: 0, y: 0 };\n      showTooltip({\n        tooltipData: datum,\n        tooltipLeft: x,\n        tooltipTop: y,\n      });\n    },\n    [showTooltip],\n  );\n\n  const tooltipStyles = {\n    ...defaultStyles,\n    minWidth: 50,\n    backgroundColor: \"var(--background)\",\n    color: \"var(--foreground)\",\n    borderRadius: \"var(--radius)\",\n    padding: \"8px\",\n    fontSize: \"12px\",\n  };\n\n  return (\n    <div style={{ position: \"relative\" }}>\n      <svg width={width} height={height}>\n        <rect x={0} y={0} width={width} height={height} fill=\"var(--card)\" rx={14} />\n        <defs>\n          <LinearGradient\n            id={gradientId}\n            from=\"var(--chart1)\"\n            to=\"var(--chart2)\"\n            fromOpacity={fillOpacity}\n            toOpacity={0.1}\n          />\n        </defs>\n\n        <Group left={centerX} top={centerY}>\n          {showGrid && (\n            <>\n              {[...new Array(levels)].map((_, i) => {\n                const r = Math.round((radius / levels) * (i + 1) * 10000) / 10000;\n                const pathData = genRadialGridPath(angles, r);\n                return (\n                  <path\n                    key={`grid-${i}`}\n                    d={pathData}\n                    fill=\"transparent\"\n                    stroke=\"var(--border)\"\n                    strokeWidth={1}\n                    strokeOpacity={0.3}\n                  />\n                );\n              })}\n\n              {angles\n                .slice(0, -1)\n                .map((angle, i) =>\n                  animated ? (\n                    <motion.line\n                      key={`axis-${i}`}\n                      x1={0}\n                      y1={0}\n                      x2={Math.round(radius * Math.cos((angle.angle * Math.PI) / 180) * 10000) / 10000}\n                      y2={Math.round(radius * Math.sin((angle.angle * Math.PI) / 180) * 10000) / 10000}\n                      stroke=\"var(--border)\"\n                      strokeWidth={1}\n                      strokeOpacity={0.3}\n                      initial={{ pathLength: 0 }}\n                      animate={{ pathLength: 1 }}\n                      transition={{ duration: 0.8, delay: i * 0.1, ease: \"easeOut\" }}\n                    />\n                  ) : (\n                    <line\n                      key={`axis-${i}`}\n                      x1={0}\n                      y1={0}\n                      x2={Math.round(radius * Math.cos((angle.angle * Math.PI) / 180) * 10000) / 10000}\n                      y2={Math.round(radius * Math.sin((angle.angle * Math.PI) / 180) * 10000) / 10000}\n                      stroke=\"var(--border)\"\n                      strokeWidth={1}\n                      strokeOpacity={0.3}\n                    />\n                  ),\n                )}\n            </>\n          )}\n\n          {animated ? (\n            <motion.polygon\n              points={polygonPoints}\n              fill={`url(#${gradientId})`}\n              stroke=\"var(--chart1)\"\n              strokeWidth={2}\n              initial={{ scale: 0, opacity: 0 }}\n              animate={{ scale: 1, opacity: 1 }}\n              transition={{ duration: 0.8, delay: 0.3, ease: \"easeOut\" }}\n            />\n          ) : (\n            <polygon points={polygonPoints} fill={`url(#${gradientId})`} stroke=\"var(--chart1)\" strokeWidth={2} />\n          )}\n\n          {points.map((point, i) =>\n            animated ? (\n              <motion.circle\n                key={`point-${i}`}\n                cx={point.x - centerX}\n                cy={point.y - centerY}\n                r={4}\n                fill=\"var(--chart1)\"\n                stroke=\"var(--background)\"\n                strokeWidth={2}\n                style={{ cursor: \"pointer\" }}\n                onMouseMove={(event) => handleTooltip(event, point)}\n                onMouseLeave={() => hideTooltip()}\n                initial={{ scale: 0, opacity: 0 }}\n                animate={{ scale: 1, opacity: 1 }}\n                transition={{ duration: 0.5, delay: 0.5 + i * 0.1, ease: \"easeOut\" }}\n                whileHover={{ scale: 1.2 }}\n              />\n            ) : (\n              <circle\n                key={`point-${i}`}\n                cx={point.x - centerX}\n                cy={point.y - centerY}\n                r={4}\n                fill=\"var(--chart1)\"\n                stroke=\"var(--background)\"\n                strokeWidth={2}\n                style={{ cursor: \"pointer\" }}\n                onMouseMove={(event) => handleTooltip(event, point)}\n                onMouseLeave={() => hideTooltip()}\n              />\n            ),\n          )}\n        </Group>\n\n        {showLabels &&\n          data.map((item, i) => {\n            const step = (Math.PI * 2) / data.length;\n            const angle = i * step;\n            const labelRadius = radius * 0.95;\n\n            let labelX = centerX + labelRadius * Math.cos(angle);\n            let labelY = centerY + labelRadius * Math.sin(angle);\n\n            const cos = Math.cos(angle);\n            const sin = Math.sin(angle);\n\n            let textAnchor: \"start\" | \"middle\" | \"end\" = \"middle\";\n            if (cos > 0.1) textAnchor = \"start\";\n            else if (cos < -0.1) textAnchor = \"end\";\n\n            let dominantBaseline: \"middle\" | \"hanging\" | \"text-before-edge\" = \"middle\";\n            if (sin < -0.1) dominantBaseline = \"text-before-edge\";\n            else if (sin > 0.1) dominantBaseline = \"hanging\";\n\n            const margin = 15;\n            labelX = Math.max(margin, Math.min(width - margin, labelX));\n            labelY = Math.max(margin, Math.min(height - margin, labelY));\n\n            return animated ? (\n              <motion.text\n                key={`label-${i}`}\n                x={labelX}\n                y={labelY}\n                textAnchor={textAnchor}\n                dominantBaseline={dominantBaseline}\n                fontSize={11}\n                fill=\"var(--muted-foreground)\"\n                fontWeight=\"500\"\n                initial={{ opacity: 0 }}\n                animate={{ opacity: 1 }}\n                transition={{ duration: 0.5, delay: 0.8 + i * 0.05, ease: \"easeOut\" }}\n              >\n                {item.category}\n              </motion.text>\n            ) : (\n              <text\n                key={`label-${i}`}\n                x={labelX}\n                y={labelY}\n                textAnchor={textAnchor}\n                dominantBaseline={dominantBaseline}\n                fontSize={11}\n                fill=\"var(--muted-foreground)\"\n                fontWeight=\"500\"\n              >\n                {item.category}\n              </text>\n            );\n          })}\n      </svg>\n\n      {tooltipData ? (\n        <TooltipWithBounds top={tooltipTop} left={tooltipLeft} style={tooltipStyles} offsetLeft={15} offsetTop={-10}>\n          <div style={{ textAlign: \"center\" }}>\n            <div style={{ fontSize: \"11px\", fontWeight: \"500\", marginBottom: \"2px\" }}>{tooltipData.category}</div>\n            <div style={{ fontSize: \"11px\", fontFamily: \"monospace\" }}>{tooltipData.value.toLocaleString()}</div>\n          </div>\n        </TooltipWithBounds>\n      ) : null}\n    </div>\n  );\n}\n\nexport default RadarChart;\n",
      "type": "registry:file",
      "target": "~/components/ui/charts/radar-chart.tsx"
    }
  ]
}