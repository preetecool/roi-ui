{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "line-chart",
  "type": "registry:item",
  "title": "Line Chart",
  "description": "Interactive line charts with optional data points and smooth animations.",
  "dependencies": [
    "@visx/group",
    "@visx/scale",
    "@visx/axis",
    "@visx/shape",
    "@visx/gradient",
    "@visx/grid",
    "@visx/tooltip",
    "@visx/event",
    "@visx/glyph",
    "@visx/curve",
    "d3-array",
    "@visx/responsive"
  ],
  "files": [
    {
      "path": "registry/brook/ui/charts/chart-tooltip.tsx",
      "content": "\"use client\";\n\nimport { TooltipWithBounds, defaultStyles } from \"@visx/tooltip\";\n\ntype NumberValue = number | { valueOf(): number };\n\nexport interface ChartDataItem {\n  type: string;\n  [key: string]: unknown;\n}\n\nexport interface ChartTooltipProps<T extends ChartDataItem> {\n  tooltipData: T[];\n  tooltipLeft: number;\n  tooltipTop: number;\n  uniqueTypes: string[];\n  colors: string[];\n  getRD: (d: T) => number;\n  getDate: (d: T) => NumberValue | string;\n  dateFormatter?: (value: NumberValue | string) => string;\n}\n\nexport default function ChartTooltip<T extends ChartDataItem>({\n  tooltipData,\n  tooltipLeft,\n  tooltipTop,\n  uniqueTypes,\n  colors,\n  getRD,\n  getDate,\n  dateFormatter,\n}: ChartTooltipProps<T>) {\n  const tooltipStyles = {\n    ...defaultStyles,\n    minWidth: 50,\n    backgroundColor: \"var(--background)\",\n\n    color: \"var(--foreground)\",\n    borderRadius: \"var(--radius)\",\n    padding: \"8px\",\n    fontSize: \"12px\",\n    transition: \"all 200ms linear\",\n  };\n\n  return (\n    <TooltipWithBounds top={tooltipTop} left={tooltipLeft} style={tooltipStyles} offsetLeft={15} offsetTop={-10}>\n      <p style={{ marginBottom: \"6px\", fontSize: \"11px\", fontWeight: \"500\" }}>\n        {dateFormatter ? dateFormatter(getDate(tooltipData[0])) : String(getDate(tooltipData[0]))}\n      </p>\n      {tooltipData.map((d, i) => (\n        <div\n          key={i}\n          style={{\n            display: \"flex\",\n            alignItems: \"center\",\n            justifyContent: \"space-between\",\n            marginBottom: \"4px\",\n            gap: \"12px\",\n          }}\n        >\n          <div style={{ display: \"flex\", alignItems: \"center\", gap: \"4px\" }}>\n            <div\n              style={{\n                width: \"6px\",\n                height: \"6px\",\n                backgroundColor: colors[uniqueTypes.indexOf(d.type)],\n                borderRadius: \"50%\",\n              }}\n            />\n            <span style={{ fontSize: \"11px\", color: \"var(--muted-foreground)\" }}>\n              {d.type.charAt(0) + d.type.slice(1).toLowerCase()}\n            </span>\n          </div>\n          <span style={{ fontSize: \"11px\", fontFamily: \"monospace\" }}>{getRD(d)}M</span>\n        </div>\n      ))}\n    </TooltipWithBounds>\n  );\n}\n",
      "type": "registry:file",
      "target": "~/components/ui/charts/chart-tooltip.tsx"
    },
    {
      "path": "registry/brook/ui/charts/line-chart.tsx",
      "content": "\"use client\";\n\nimport { useCallback, Fragment } from \"react\";\nimport { Group } from \"@visx/group\";\nimport { scaleLinear } from \"@visx/scale\";\nimport { AxisLeft, AxisBottom } from \"@visx/axis\";\nimport { Line, LinePath } from \"@visx/shape\";\nimport { extent, bisector } from \"d3-array\";\n\ntype NumberValue = number | { valueOf(): number };\nimport { line } from \"d3-shape\";\nimport { LinearGradient } from \"@visx/gradient\";\nimport { GridRows, GridColumns } from \"@visx/grid\";\nimport { useTooltip } from \"@visx/tooltip\";\nimport ChartTooltip, { ChartDataItem } from \"./chart-tooltip\";\nimport { localPoint } from \"@visx/event\";\nimport { GlyphCircle } from \"@visx/glyph\";\nimport { curveLinear, curveMonotoneX, curveCardinal, curveBasis, curveStep } from \"@visx/curve\";\nimport { motion } from \"motion/react\";\n\nexport interface LineChartData extends ChartDataItem {\n  date: NumberValue;\n  value: number;\n  type: string;\n}\n\nexport type CurveType = \"linear\" | \"monotoneX\" | \"cardinal\" | \"basis\" | \"step\";\n\nexport interface Margin {\n  top: number;\n  right: number;\n  bottom: number;\n  left: number;\n}\n\nexport interface LineChartProps {\n  data: LineChartData[];\n  width: number;\n  height: number;\n  showXAxis?: boolean;\n  showYAxis?: boolean;\n  showXGrid?: boolean;\n  showYGrid?: boolean;\n  curve?: CurveType;\n  showPoints?: boolean;\n  pointSize?: number;\n  margin?: Margin;\n  xAxisFormatter?: (value: NumberValue | string) => string;\n  animated?: boolean;\n}\n\nfunction LineChart({\n  data,\n  width,\n  height,\n  showXAxis = true,\n  showYAxis = true,\n  showXGrid = true,\n  showYGrid = true,\n  curve = \"linear\",\n  showPoints = false,\n  pointSize = 4,\n  margin = { top: 40, right: 40, bottom: 40, left: 40 },\n  xAxisFormatter,\n  animated = false,\n}: LineChartProps) {\n  const { tooltipData, tooltipLeft = 0, tooltipTop = 0, showTooltip, hideTooltip } = useTooltip<LineChartData[]>();\n\n  const innerWidth = width - margin.left - margin.right;\n  const innerHeight = height - margin.top - margin.bottom;\n\n  const uniqueTypes = Array.from(new Set(data.map((d) => d.type)));\n  const series = uniqueTypes.map((type) => data.filter((d) => d.type === type));\n\n  const colors = [\"var(--chart1)\", \"var(--chart2)\"];\n\n  const getCurveFunction = (curveType: CurveType) => {\n    switch (curveType) {\n      case \"monotoneX\":\n        return curveMonotoneX;\n      case \"cardinal\":\n        return curveCardinal;\n      case \"basis\":\n        return curveBasis;\n      case \"step\":\n        return curveStep;\n      case \"linear\":\n      default:\n        return curveLinear;\n    }\n  };\n\n  const getRD = (d: LineChartData) => d.value;\n  const getDate = (d: LineChartData) => d.date;\n  const bisectDate = bisector((d: LineChartData) => d.date).left;\n\n  const getD = useCallback((date: NumberValue) => {\n    const output = data.filter(function (el) {\n      return el.date === date;\n    });\n    return output;\n  }, [data]);\n\n  const formatDate = (value: NumberValue | string) => {\n    if (xAxisFormatter) {\n      return xAxisFormatter(value);\n    }\n    return Math.round(Number(value)).toString();\n  };\n\n  const timeScale = scaleLinear({\n    range: [0, innerWidth],\n    domain: extent(data, getDate) as [number, number],\n    nice: true,\n  });\n\n  const rdScale = scaleLinear({\n    range: [innerHeight, 0],\n    domain: extent(data, getRD) as [number, number],\n    nice: true,\n  });\n\n  const handleTooltip = useCallback(\n    (event: React.TouchEvent<SVGRectElement> | React.MouseEvent<SVGRectElement>) => {\n      const { x, y } = localPoint(event) || { x: 0, y: 0 };\n      const x0 = timeScale.invert(x - margin.left);\n\n      const index = bisectDate(data, x0, 1);\n      const d0 = data[index - 1];\n      const d1 = data[index];\n      let d = d0;\n\n      if (d1 && getDate(d1)) {\n        d = x0.valueOf() - getDate(d0).valueOf() > getDate(d1).valueOf() - x0.valueOf() ? d1 : d0;\n      }\n      showTooltip({\n        tooltipData: getD(d.date),\n        tooltipLeft: x,\n        tooltipTop: y,\n      });\n    },\n    [showTooltip, timeScale, margin.left, bisectDate, data, getD],\n  );\n\n  return (\n    <div style={{ position: \"relative\" }}>\n      <svg width={width} height={height}>\n        <rect x={0} y={0} width={width} height={height} fill=\"var(--card)\" rx={14} />\n        <Group left={margin.left} top={margin.top}>\n          {showYGrid && (\n            <GridRows\n              scale={rdScale}\n              width={innerWidth}\n              height={innerHeight - margin.top}\n              stroke=\"var(--border)\"\n              strokeOpacity={0.2}\n            />\n          )}\n          {showXGrid && (\n            <GridColumns\n              scale={timeScale}\n              width={innerWidth}\n              height={innerHeight}\n              stroke=\"var(--border)\"\n              strokeOpacity={0.2}\n            />\n          )}\n          <LinearGradient id=\"area-gradient\" from=\"var(--success)\" to=\"var(--success)\" toOpacity={0.1} />\n          {showYAxis && (\n            <>\n              <AxisLeft\n                stroke=\"var(--border)\"\n                tickStroke=\"var(--border)\"\n                scale={rdScale}\n                numTicks={Math.min(10, innerHeight / 40)}\n                tickLabelProps={() => ({\n                  fill: \"var(--muted-foreground)\",\n                  fontSize: 11,\n                  textAnchor: \"end\",\n                })}\n              />\n            </>\n          )}\n          {showXAxis && (\n            <AxisBottom\n              scale={timeScale}\n              stroke=\"var(--border)\"\n              tickStroke=\"var(--border)\"\n              top={innerHeight}\n              numTicks={Math.min(10, innerWidth / 80)}\n              tickFormat={formatDate}\n              tickLabelProps={() => ({\n                fill: \"var(--muted-foreground)\",\n                fontSize: 11,\n                textAnchor: \"middle\",\n              })}\n            />\n          )}\n          {series.map((sData, i) => (\n            <Fragment key={i}>\n              {animated ? (\n                <motion.g>\n                  <motion.path\n                    d={(() => {\n                      const pathGenerator = line<LineChartData>()\n                        .x((d) => timeScale(getDate(d)) ?? 0)\n                        .y((d) => rdScale(getRD(d)) ?? 0)\n                        .curve(getCurveFunction(curve));\n                      return pathGenerator(sData) || \"\";\n                    })()}\n                    stroke={colors[i]}\n                    strokeWidth={3}\n                    fill=\"none\"\n                    initial={{ strokeDasharray: \"1000 1000\", strokeDashoffset: 1000 }}\n                    animate={{ strokeDashoffset: 0 }}\n                    transition={{\n                      duration: 1.2,\n                      delay: i * 0.2,\n                      ease: \"easeOut\",\n                    }}\n                  />\n                </motion.g>\n              ) : (\n                <LinePath\n                  stroke={colors[i]}\n                  strokeWidth={3}\n                  data={sData}\n                  x={(d) => timeScale(getDate(d)) ?? 0}\n                  y={(d) => rdScale(getRD(d)) ?? 0}\n                  curve={getCurveFunction(curve)}\n                />\n              )}\n            </Fragment>\n          ))}\n          {showPoints &&\n            pointSize > 0 &&\n            series.map((sData, seriesIndex) =>\n              sData.map((d, pointIndex) => (\n                <Fragment key={`${seriesIndex}-${pointIndex}`}>\n                  {animated ? (\n                    <motion.g\n                      initial={{ scale: 0, opacity: 0 }}\n                      animate={{ scale: 1, opacity: 1 }}\n                      transition={{\n                        duration: 0.4,\n                        delay: 0.8 + (seriesIndex * sData.length + pointIndex) * 0.05,\n                        ease: \"easeOut\",\n                      }}\n                    >\n                      <GlyphCircle\n                        left={timeScale(getDate(d)) ?? 0}\n                        top={rdScale(getRD(d)) ?? 0}\n                        size={pointSize * pointSize * Math.PI}\n                        fill={colors[seriesIndex]}\n                        stroke=\"var(--background)\"\n                        strokeWidth={2}\n                      />\n                    </motion.g>\n                  ) : (\n                    <GlyphCircle\n                      left={timeScale(getDate(d)) ?? 0}\n                      top={rdScale(getRD(d)) ?? 0}\n                      size={pointSize * pointSize * Math.PI}\n                      fill={colors[seriesIndex]}\n                      stroke=\"var(--background)\"\n                      strokeWidth={2}\n                    />\n                  )}\n                </Fragment>\n              )),\n            )}\n          {tooltipData && (\n            <g>\n              <Line\n                from={{ x: tooltipLeft - margin.left, y: 0 }}\n                to={{ x: tooltipLeft - margin.left, y: innerHeight }}\n                stroke=\"var(--border)\"\n                strokeWidth={2}\n                pointerEvents=\"none\"\n                strokeDasharray=\"4,2\"\n              />\n            </g>\n          )}\n          {tooltipData &&\n            tooltipData.map((d, i) => (\n              <g key={i}>\n                <GlyphCircle\n                  left={tooltipLeft - margin.left}\n                  top={rdScale(d.value) + 2}\n                  size={110}\n                  fill={colors[i]}\n                  stroke=\"var(--background)\"\n                  strokeWidth={2}\n                />\n              </g>\n            ))}\n          <rect\n            x={0}\n            y={0}\n            width={innerWidth}\n            height={innerHeight}\n            onTouchStart={handleTooltip}\n            fill=\"transparent\"\n            onTouchMove={handleTooltip}\n            onMouseMove={handleTooltip}\n            onMouseLeave={() => hideTooltip()}\n          />\n        </Group>\n      </svg>\n      {tooltipData ? (\n        <ChartTooltip\n          tooltipData={tooltipData}\n          tooltipLeft={tooltipLeft}\n          tooltipTop={tooltipTop}\n          uniqueTypes={uniqueTypes}\n          colors={colors}\n          getRD={getRD}\n          getDate={getDate}\n          dateFormatter={xAxisFormatter}\n        />\n      ) : null}\n    </div>\n  );\n}\n\nexport default LineChart;\n",
      "type": "registry:file",
      "target": "~/components/ui/charts/line-chart.tsx"
    }
  ]
}