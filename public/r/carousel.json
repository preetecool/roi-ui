{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "carousel",
  "type": "registry:item",
  "title": "Carousel",
  "description": "A slideshow component for cycling through content.",
  "files": [
    {
      "path": "registry/brook/ui/carousel/carousel.tsx",
      "content": "\"use client\";\n\nimport { useControlled } from \"@base-ui-components/utils/useControlled\";\nimport {\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\";\nimport { cn } from \"@/lib/utils\";\nimport styles from \"./carousel.module.css\";\n\ntype CarouselContextValue = {\n  currentIndex: number;\n  setCurrentIndex: (index: number) => void;\n  totalItems: number;\n  gap: number;\n  variant: \"default\" | \"inset\";\n  goToIndex: (index: number) => void;\n  nextSlide: () => void;\n  prevSlide: () => void;\n  canGoNext: boolean;\n  canGoPrev: boolean;\n  viewportRef: React.RefObject<HTMLDivElement | null>;\n};\n\nconst CarouselContext = createContext<CarouselContextValue | null>(null);\n\nfunction useCarousel() {\n  const context = useContext(CarouselContext);\n  if (!context) {\n    throw new Error(\"Carousel components must be used within Carousel.Root\");\n  }\n  return context;\n}\n\nexport type CarouselRootProps = React.ComponentProps<\"div\"> & {\n  /** Total number of items in the carousel. */\n  totalItems: number;\n  /** Gap between items in pixels. @default 16 */\n  gap?: number;\n  /** Controlled index value. */\n  index?: number;\n  /** Default index for uncontrolled mode. @default 0 */\n  defaultIndex?: number;\n  /** Callback when index changes. */\n  onIndexChange?: (index: number) => void;\n  /** Align carousel content. @default \"start\" */\n  align?: \"start\" | \"center\";\n  /** Carousel variant. @default \"default\" */\n  variant?: \"default\" | \"inset\";\n};\n\n/** Root component. Manages state and provides context. */\nexport function Root({\n  children,\n  totalItems,\n  gap = 16,\n  index: indexProp,\n  defaultIndex = 0,\n  onIndexChange,\n  align = \"start\",\n  variant = \"default\",\n  className,\n  ...props\n}: CarouselRootProps) {\n  const [currentIndex, setCurrentIndexInternal] = useControlled({\n    controlled: indexProp,\n    default: defaultIndex,\n    name: \"Carousel\",\n    state: \"index\",\n  });\n\n  const viewportRef = useRef<HTMLDivElement>(null);\n  const bleedRefFromContext = useBleedRef();\n  const [insetPaddingLeft, setInsetPaddingLeft] = useState(0);\n  const [insetPaddingRight, setInsetPaddingRight] = useState(0);\n\n  const maxIndex = totalItems - 1;\n  const canGoNext = currentIndex < maxIndex;\n  const canGoPrev = currentIndex > 0;\n\n  const setCurrentIndex = useCallback(\n    (index: number) => {\n      setCurrentIndexInternal(index);\n      onIndexChange?.(index);\n    },\n    [setCurrentIndexInternal, onIndexChange]\n  );\n\n  const goToIndex = useCallback(\n    (index: number) => {\n      const viewport = viewportRef.current;\n      if (!viewport) {\n        return;\n      }\n\n      const slides = viewport.querySelectorAll('[role=\"group\"]');\n      const targetSlide = slides[index] as HTMLElement;\n\n      if (targetSlide) {\n        let targetScroll = targetSlide.offsetLeft;\n\n        // For inset variant, adjust scroll position to account for left padding\n        if (variant === \"inset\" && bleedRefFromContext?.current) {\n          const parent = bleedRefFromContext.current.parentElement;\n          if (parent) {\n            const parentRect = parent.getBoundingClientRect();\n            const leftPadding = parentRect.left;\n            targetScroll = targetSlide.offsetLeft - leftPadding;\n          }\n        }\n\n        viewport.scrollTo({ left: targetScroll, behavior: \"smooth\" });\n      }\n\n      setCurrentIndex(index);\n    },\n    [setCurrentIndex, variant, bleedRefFromContext]\n  );\n\n  const getVisibleItemsCount = useCallback(() => {\n    const viewport = viewportRef.current;\n    if (!viewport) {\n      return 1;\n    }\n\n    const slides = viewport.querySelectorAll('[role=\"group\"]');\n    if (slides.length === 0) {\n      return 1;\n    }\n\n    const viewportRect = viewport.getBoundingClientRect();\n    let visibleCount = 0;\n    const VISIBILITY_THRESHOLD = 0.5;\n\n    for (const slide of slides) {\n      const slideRect = slide.getBoundingClientRect();\n      // Check if slide is at least 50% visible in viewport\n      const visibleWidth =\n        Math.min(slideRect.right, viewportRect.right) -\n        Math.max(slideRect.left, viewportRect.left);\n      const slideWidth = slideRect.width;\n\n      if (visibleWidth / slideWidth >= VISIBILITY_THRESHOLD) {\n        visibleCount++;\n      }\n    }\n\n    return Math.max(1, visibleCount);\n  }, []);\n\n  const nextSlide = useCallback(() => {\n    const visibleItems = getVisibleItemsCount();\n    const newIndex = Math.min(currentIndex + visibleItems, maxIndex);\n    goToIndex(newIndex);\n  }, [currentIndex, maxIndex, goToIndex, getVisibleItemsCount]);\n\n  const prevSlide = useCallback(() => {\n    const visibleItems = getVisibleItemsCount();\n    const newIndex = Math.max(currentIndex - visibleItems, 0);\n    goToIndex(newIndex);\n  }, [currentIndex, goToIndex, getVisibleItemsCount]);\n\n  const value: CarouselContextValue = {\n    currentIndex,\n    setCurrentIndex,\n    totalItems,\n    gap,\n    variant,\n    goToIndex,\n    nextSlide,\n    prevSlide,\n    canGoNext,\n    canGoPrev,\n    viewportRef,\n  };\n\n  // Calculate inset padding based on parent container\n  useEffect(() => {\n    if (\n      variant !== \"inset\" ||\n      !bleedRefFromContext?.current ||\n      !viewportRef.current\n    ) {\n      return;\n    }\n\n    const calculatePadding = () => {\n      const bleed = bleedRefFromContext.current;\n      const viewport = viewportRef.current;\n      if (!(bleed && viewport)) {\n        return;\n      }\n\n      const parent = bleed.parentElement;\n      if (!parent) {\n        return;\n      }\n\n      const parentRect = parent.getBoundingClientRect();\n      const viewportRect = viewport.getBoundingClientRect();\n\n      // Get parent's computed padding to account for container padding\n      const parentStyles = window.getComputedStyle(parent);\n      const parentPaddingLeft = Number.parseFloat(parentStyles.paddingLeft);\n      const parentPaddingRight = Number.parseFloat(parentStyles.paddingRight);\n\n      // Calculate the padding needed to align cards with parent's content area (inside padding)\n      // Left padding: distance from viewport's left edge to parent's content left edge, minus gap\n      const leftPadding = Math.max(\n        0,\n        parentRect.left + parentPaddingLeft - viewportRect.left - gap\n      );\n\n      // Right padding: distance from parent's content right edge to viewport's right edge\n      const rightPadding = Math.max(\n        0,\n        viewportRect.right - (parentRect.right - parentPaddingRight)\n      );\n\n      setInsetPaddingLeft(leftPadding);\n      setInsetPaddingRight(rightPadding);\n    };\n\n    calculatePadding();\n\n    window.addEventListener(\"resize\", calculatePadding);\n    return () => window.removeEventListener(\"resize\", calculatePadding);\n  }, [variant, bleedRefFromContext, gap]);\n\n  return (\n    <CarouselContext.Provider value={value}>\n      <div\n        className={cn(\n          styles.carousel,\n          align === \"center\" && styles.carouselCenter,\n          className\n        )}\n        data-slot=\"carousel\"\n        style={\n          {\n            \"--calculated-inset-padding-left\": `${insetPaddingLeft}px`,\n            \"--calculated-inset-padding-right\": `${insetPaddingRight}px`,\n          } as React.CSSProperties\n        }\n        {...props}\n      >\n        {children}\n        <div aria-atomic=\"true\" aria-live=\"polite\" className={styles.srOnly}>\n          Item {currentIndex + 1} of {totalItems}\n        </div>\n      </div>\n    </CarouselContext.Provider>\n  );\n}\n\nexport type CarouselBleedProps = React.ComponentProps<\"div\">;\n\nconst BleedRefContext =\n  createContext<React.RefObject<HTMLDivElement | null> | null>(null);\n\nexport function useBleedRef() {\n  return useContext(BleedRefContext);\n}\n\n/** Bleed wrapper. Extends carousel to full viewport width. */\nexport function Bleed({ className, children, ...props }: CarouselBleedProps) {\n  const bleedRef = useRef<HTMLDivElement | null>(null);\n\n  return (\n    <BleedRefContext.Provider value={bleedRef}>\n      <div className={cn(styles.bleed, className)} ref={bleedRef} {...props}>\n        {children}\n      </div>\n    </BleedRefContext.Provider>\n  );\n}\n\nexport type CarouselViewportProps = React.ComponentProps<\"div\">;\n\n/** Scrollable viewport. */\nexport function Viewport({\n  className,\n  children,\n  ...props\n}: CarouselViewportProps) {\n  const { viewportRef } = useCarousel();\n\n  return (\n    <div\n      aria-atomic=\"false\"\n      aria-live=\"polite\"\n      className={cn(styles.viewport, className)}\n      ref={viewportRef}\n      {...props}\n    >\n      {children}\n    </div>\n  );\n}\n\nexport type CarouselContentProps = React.ComponentProps<\"div\">;\n\n/** Content wrapper. Flex container for horizontal layout. */\nexport function Content({\n  className,\n  children,\n  ...props\n}: CarouselContentProps) {\n  const { gap, variant } = useCarousel();\n\n  return (\n    <div\n      className={cn(styles.container, className)}\n      style={\n        {\n          gap: `${gap}px`,\n          \"--inset-padding-left\":\n            variant === \"inset\"\n              ? \"var(--calculated-inset-padding-left, max(var(--min-edge), var(--min-padding)))\"\n              : undefined,\n          \"--inset-padding-right\":\n            variant === \"inset\"\n              ? \"var(--calculated-inset-padding-right, max(var(--min-edge), var(--min-padding)))\"\n              : undefined,\n        } as React.CSSProperties\n      }\n      {...props}\n    >\n      {children}\n    </div>\n  );\n}\n\nexport type CarouselItemProps = React.ComponentProps<\"div\"> & {\n  /** Item index (required). */\n  index: number;\n};\n\n/** Individual carousel slide. */\nexport function Item({\n  index,\n  className,\n  children,\n  ...props\n}: CarouselItemProps) {\n  const { totalItems, goToIndex, nextSlide, prevSlide, canGoNext, canGoPrev } =\n    useCarousel();\n\n  const isVisible = true;\n\n  const handleKeyDown = useCallback(\n    (e: React.KeyboardEvent) => {\n      switch (e.key) {\n        case \"ArrowLeft\":\n          if (canGoPrev) {\n            e.preventDefault();\n            prevSlide();\n          }\n          break;\n        case \"ArrowRight\":\n          if (canGoNext) {\n            e.preventDefault();\n            nextSlide();\n          }\n          break;\n        case \"Home\":\n          e.preventDefault();\n          goToIndex(0);\n          break;\n        case \"End\":\n          e.preventDefault();\n          goToIndex(totalItems - 1);\n          break;\n        default:\n          // No action for other keys\n          break;\n      }\n    },\n    [canGoPrev, canGoNext, prevSlide, nextSlide, goToIndex, totalItems]\n  );\n\n  return (\n    // biome-ignore lint/a11y/noNoninteractiveElementInteractions: Keyboard navigation is required for carousel accessibility\n    <div\n      aria-label={`${index + 1} of ${totalItems}`}\n      aria-roledescription=\"slide\"\n      className={cn(styles.slide, className)}\n      onKeyDown={handleKeyDown}\n      role=\"group\"\n      tabIndex={isVisible ? 0 : -1}\n      {...props}\n    >\n      {children}\n    </div>\n  );\n}\n\nexport type CarouselPreviousProps = React.ComponentProps<\"button\">;\n\n/** Previous button. Auto-disabled at start. */\nexport function Previous({\n  className,\n  children,\n  ...props\n}: CarouselPreviousProps) {\n  const { prevSlide, canGoPrev } = useCarousel();\n\n  return (\n    <button\n      aria-controls=\"carousel-slides\"\n      aria-label=\"Scroll to previous items\"\n      className={cn(styles.navButton, className)}\n      disabled={!canGoPrev}\n      onClick={prevSlide}\n      type=\"button\"\n      {...props}\n    >\n      {children || (\n        <svg\n          aria-hidden=\"true\"\n          fill=\"none\"\n          stroke=\"currentColor\"\n          strokeWidth=\"2\"\n          viewBox=\"0 0 24 24\"\n        >\n          <path d=\"m15 18-6-6 6-6\" />\n        </svg>\n      )}\n    </button>\n  );\n}\n\nexport type CarouselNextProps = React.ComponentProps<\"button\">;\n\n/** Next button. Auto-disabled at end. */\nexport function Next({ className, children, ...props }: CarouselNextProps) {\n  const { nextSlide, canGoNext } = useCarousel();\n\n  return (\n    <button\n      aria-controls=\"carousel-slides\"\n      aria-label=\"Scroll to next items\"\n      className={cn(styles.navButton, className)}\n      disabled={!canGoNext}\n      onClick={nextSlide}\n      type=\"button\"\n      {...props}\n    >\n      {children || (\n        <svg\n          aria-hidden=\"true\"\n          fill=\"none\"\n          stroke=\"currentColor\"\n          strokeWidth=\"2\"\n          viewBox=\"0 0 24 24\"\n        >\n          <path d=\"m9 18 6-6-6-6\" />\n        </svg>\n      )}\n    </button>\n  );\n}\n\nexport type CarouselNavigationProps = React.ComponentProps<\"div\">;\n\n/** Navigation wrapper. Renders default buttons if no children provided. Hidden with one item. */\nexport function Navigation({\n  className,\n  children,\n  ...props\n}: CarouselNavigationProps) {\n  const { totalItems, variant } = useCarousel();\n\n  if (totalItems <= 1) {\n    return null;\n  }\n\n  return (\n    <div\n      className={cn(styles.navContainer, className)}\n      style={\n        variant === \"inset\"\n          ? ({\n              \"--inset-padding\": \"var(--calculated-inset-padding, 0)\",\n            } as React.CSSProperties)\n          : undefined\n      }\n      {...props}\n    >\n      {children || (\n        <>\n          <Previous />\n          <Next />\n        </>\n      )}\n    </div>\n  );\n}\n\nexport type CarouselIndicatorsProps = React.ComponentProps<\"div\">;\n\n/** Dot indicators for each item. Hidden with one item. */\nexport function Indicators({ className, ...props }: CarouselIndicatorsProps) {\n  const { totalItems, currentIndex, goToIndex } = useCarousel();\n\n  if (totalItems <= 1) {\n    return null;\n  }\n\n  return (\n    <div\n      aria-label=\"Choose slide to display\"\n      className={cn(styles.indicators, className)}\n      role=\"tablist\"\n      {...props}\n    >\n      {Array.from({ length: totalItems }, (_, index) => (\n        <button\n          aria-controls=\"carousel-slides\"\n          aria-label={`Scroll to item ${index + 1}`}\n          aria-selected={currentIndex === index}\n          className={cn(\n            styles.indicator,\n            currentIndex === index && styles.indicatorActive\n          )}\n          // biome-ignore lint/suspicious/noArrayIndexKey: Indicators are stable and don't reorder\n          key={`indicator-${index}`}\n          onClick={() => goToIndex(index)}\n          role=\"tab\"\n          type=\"button\"\n        />\n      ))}\n    </div>\n  );\n}\n\n/**\n * Composable carousel component with horizontal scrolling.\n * Built-in keyboard navigation with arrow keys, Home, and End.\n * Built-in screen reader announcements for current position.\n * Required: Carousel.Root, Carousel.Viewport, Carousel.Content, Carousel.Item.\n * Optional: Carousel.Bleed, Carousel.Navigation, Carousel.Previous, Carousel.Next, Carousel.Indicators.\n */\nexport const Carousel = {\n  Root,\n  Bleed,\n  Viewport,\n  Content,\n  Item,\n  Previous,\n  Next,\n  Navigation,\n  Indicators,\n};\n",
      "type": "registry:file",
      "target": "~/components/ui/carousel/carousel.tsx"
    },
    {
      "path": "registry/brook/ui/carousel/carousel.module.css",
      "content": ".carousel {\n  --page-max-width: 1280px;\n  --page-padding-left: 1rem;\n  --carousel-gap: 16px;\n  --edge: calc((100vw - var(--page-max-width)) / 2);\n  --min-edge: calc(var(--edge) - var(--carousel-gap));\n  --min-padding: calc(var(--page-padding-left) - var(--carousel-gap));\n\n  position: relative;\n  width: 100%;\n  margin: 0 auto;\n  border-radius: 0.5rem;\n  overflow: visible;\n}\n\n.carouselCenter {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n\n.bleed {\n  width: 100vw;\n  margin-left: -50vw;\n  margin-right: -50vw;\n  position: relative;\n  left: 50%;\n  right: 50%;\n}\n\n@media (max-width: 640px) {\n  .bleed {\n    left: calc(50% - 20vw);\n  }\n}\n\n.carousel:focus-visible {\n  outline: 2px solid var(--ring);\n  outline-offset: 2px;\n}\n\n.viewport {\n  position: relative;\n  width: 100%;\n  overflow-x: scroll;\n  overflow-y: hidden;\n  overscroll-behavior-x: contain;\n  scroll-snap-stop: always;\n  padding-block: calc(\n    var(--focus-ring-width, 2px) +\n    var(--focus-ring-offset, 2px)\n  );\n  scrollbar-width: none;\n  -ms-overflow-style: none;\n}\n\n.viewport::-webkit-scrollbar {\n  display: none;\n}\n\n.container {\n  display: flex;\n  align-items: stretch;\n}\n\n.container::before {\n  content: \"\";\n  flex-shrink: 0;\n  width: var(--inset-padding-left, 0);\n}\n\n.container::after {\n  content: \"\";\n  flex-shrink: 0;\n  width: var(--inset-padding-right, 0);\n}\n\n.slide {\n  flex-shrink: 0;\n  position: relative;\n}\n\n.slide:focus-visible {\n  outline: 2px solid var(--ring);\n  outline-offset: -2px;\n}\n\n.navContainer {\n  display: flex;\n  justify-content: center;\n  gap: 0.5rem;\n  margin-top: 3rem;\n}\n\n.navButton {\n  position: relative;\n  width: 2.5rem;\n  height: 2.5rem;\n  border-radius: 50%;\n  border: 0.5px solid oklch(from var(--border) l c h / 0.8);\n  background: var(--card);\n  color: var(--foreground);\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  box-shadow: var(--shadow-md);\n  transition: all 0.2s var(--ease-out-quad);\n  opacity: 0.9;\n}\n\n.navButton:hover {\n  opacity: 1;\n  background: var(--muted);\n  transform: scale(1.05);\n}\n\n.navButton:focus-visible {\n  outline: 2px solid var(--ring);\n  outline-offset: 2px;\n}\n\n.navButton:active {\n  transform: scale(0.95);\n}\n\n.navButton:disabled {\n  opacity: 0.3;\n  cursor: default;\n  background: var(--muted);\n  color: var(--muted-foreground);\n  pointer-events: none;\n}\n\n.navButton:disabled:hover {\n  opacity: 0.3;\n  transform: none;\n  background: var(--muted);\n}\n\n.navButton svg {\n  width: 1rem;\n  height: 1rem;\n}\n\n@media (prefers-reduced-motion: reduce) {\n  .navButton {\n    transition: none;\n  }\n}\n\n.indicators {\n  position: absolute;\n  bottom: 1rem;\n  left: 50%;\n  transform: translateX(-50%);\n  display: flex;\n  gap: 0.5rem;\n  z-index: 10;\n}\n\n.indicator {\n  width: 0.75rem;\n  height: 0.75rem;\n  border-radius: 50%;\n  border: none;\n  background: rgba(255, 255, 255, 0.5);\n  cursor: pointer;\n  transition: all 0.2s ease;\n  position: relative;\n}\n\n.indicator:hover {\n  background: rgba(255, 255, 255, 0.7);\n  transform: scale(1.1);\n}\n\n.indicator:focus-visible {\n  outline: 2px solid var(--ring);\n  outline-offset: 2px;\n}\n\n.indicatorActive {\n  background: var(--primary);\n  transform: scale(1.2);\n}\n\n.indicatorActive:hover {\n  background: var(--primary);\n}\n\n.srOnly {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border: 0;\n}\n\n@media (prefers-reduced-motion: reduce) {\n  .indicator {\n    transition: none;\n  }\n}\n",
      "type": "registry:file",
      "target": "~/components/ui/carousel/carousel.module.css"
    }
  ]
}