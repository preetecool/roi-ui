import type { Dirent } from "node:fs";
import { promises as fs } from "node:fs";
import path from "node:path";

const FILE_EXTENSION_REGEX = /\.(tsx?|jsx?)$/;
const MAX_IMPORT_LINE_LENGTH = 44;

/**
 * Get all files in a directory (tsx and css)
 */
async function getComponentFiles(dir: string, name: string): Promise<string[]> {
  const files: string[] = [];
  const basePath = path.join(dir, name);
  const cwd = process.cwd();

  try {
    const stat = await fs.stat(basePath);
    if (stat.isDirectory()) {
      const dirFiles = await fs.readdir(basePath);
      for (const file of dirFiles) {
        if (file.endsWith(".tsx") || file.endsWith(".module.css")) {
          const fullPath = path.join(basePath, file);
          files.push(path.relative(cwd, fullPath));
        }
      }
    } else {
      files.push(path.relative(cwd, basePath));
    }
  } catch {
    try {
      const tsxPath = `${basePath}.tsx`;
      await fs.stat(tsxPath);
      files.push(path.relative(cwd, tsxPath));
    } catch {
      // Doesn't exist
    }
  }

  return files.sort((a, b) => {
    const aIsTsx = a.endsWith(".tsx");
    const bIsTsx = b.endsWith(".tsx");
    if (aIsTsx && !bIsTsx) return -1;
    if (!aIsTsx && bIsTsx) return 1;
    return 0;
  });
}

async function buildOptimizedRegistry() {
  const examplesDir = path.join(process.cwd(), "registry/brook/examples");
  const blocksDir = path.join(process.cwd(), "registry/brook/blocks");
  const uiDir = path.join(process.cwd(), "registry/brook/ui");
  const tailwindExamplesDir = path.join(process.cwd(), "registry/brook/tailwind/examples");
  const tailwindBlocksDir = path.join(process.cwd(), "registry/brook/tailwind/blocks");
  const tailwindUiDir = path.join(process.cwd(), "registry/brook/tailwind/ui");

  const examplesEntries = await fs.readdir(examplesDir, {
    withFileTypes: true,
  });

  let blocksEntries: Dirent[] = [];
  try {
    blocksEntries = await fs.readdir(blocksDir, { withFileTypes: true });
  } catch {
    // blocks directory might not exist
  }

  let uiEntries: Dirent[] = [];
  try {
    uiEntries = await fs.readdir(uiDir, { withFileTypes: true });
  } catch {
    // ui directory might not exist
  }

  let tailwindExamplesEntries: Dirent[] = [];
  try {
    tailwindExamplesEntries = await fs.readdir(tailwindExamplesDir, {
      withFileTypes: true,
    });
  } catch {
    // tailwind examples directory might not exist
  }

  let tailwindBlocksEntries: Dirent[] = [];
  try {
    tailwindBlocksEntries = await fs.readdir(tailwindBlocksDir, {
      withFileTypes: true,
    });
  } catch {
    // tailwind blocks directory might not exist
  }

  let tailwindUiEntries: Dirent[] = [];
  try {
    tailwindUiEntries = await fs.readdir(tailwindUiDir, {
      withFileTypes: true,
    });
  } catch {
    // tailwind ui directory might not exist
  }

  // Metadata-only index (lightweight, no component imports)
  let metadataIndex = `// @generated
// This file is autogenerated by scripts/build-registry-index.ts
// Do not edit this file directly.
// @ts-nocheck

type RegistryEntry = {
  name: string;
  type: "example" | "block" | "ui";
  files?: string[];
  path?: string;
};

export const Index: Record<string, RegistryEntry> = {`;

  // Component loaders (only loaded when needed)
  let loadersIndex = `// @generated
// This file is autogenerated by scripts/build-registry-index.ts
// Do not edit this file directly.
// @ts-nocheck
import type { ComponentType } from "react";
import { lazy } from "react";

export const ComponentLoaders: Record<string, ComponentType> = {`;

  // Process examples
  for (const entry of examplesEntries) {
    const name = entry.name.replace(FILE_EXTENSION_REGEX, "");
    const isFile = entry.isFile();
    const componentPath = isFile ? `@/registry/brook/examples/${name}` : `@/registry/brook/examples/${name}/${name}`;

    const files = await getComponentFiles(examplesDir, entry.name);
    const filesArray = files.length > 0 ? `["${files.join('", "')}"]` : "[]";
    const key = name.includes("-") ? `"${name}"` : name;

    // Metadata
    metadataIndex += `
  ${key}: {
    name: "${name}",
    type: "example",
    files: ${filesArray},
    path: "${componentPath}",
  },`;

    // Loader
    const importStatement =
      componentPath.length > MAX_IMPORT_LINE_LENGTH
        ? `const mod = await import(
        "${componentPath}"
      );`
        : `const mod = await import("${componentPath}");`;

    loadersIndex += `
  ${key}: lazy(async () => {
    ${importStatement}
    const exportName =
      Object.keys(mod).find(
        (key) =>
          typeof mod[key] === "function" || typeof mod[key] === "object"
      ) || "${name}";
    return { default: mod.default || mod[exportName] };
  }),`;
  }

  // Process blocks
  for (const entry of blocksEntries) {
    const name = entry.name.replace(FILE_EXTENSION_REGEX, "");
    const isFile = entry.isFile();
    const componentPath = isFile ? `@/registry/brook/blocks/${name}` : `@/registry/brook/blocks/${name}/${name}`;

    const files = await getComponentFiles(blocksDir, entry.name);
    const filesArray = files.length > 0 ? `["${files.join('", "')}"]` : "[]";
    const key = name.includes("-") ? `"${name}"` : name;

    // Metadata
    metadataIndex += `
  ${key}: {
    name: "${name}",
    type: "block",
    files: ${filesArray},
    path: "${componentPath}",
  },`;

    // Loader
    const importStatement =
      componentPath.length > MAX_IMPORT_LINE_LENGTH
        ? `const mod = await import(
        "${componentPath}"
      );`
        : `const mod = await import("${componentPath}");`;

    loadersIndex += `
  ${key}: lazy(async () => {
    ${importStatement}
    const exportName =
      Object.keys(mod).find(
        (key) =>
          typeof mod[key] === "function" || typeof mod[key] === "object"
      ) || "${name}";
    return { default: mod.default || mod[exportName] };
  }),`;
  }

  // Process UI components (no component loading, just metadata)
  for (const entry of uiEntries) {
    const name = entry.name;
    const files = await getComponentFiles(uiDir, name);

    if (files.length === 0) continue;

    const filesArray = `["${files.join('", "')}"]`;
    const key = name.includes("-") ? `"${name}"` : name;

    metadataIndex += `
  ${key}: {
    name: "${name}",
    type: "ui",
    files: ${filesArray},
  },`;
  }

  // Process tailwind examples
  for (const entry of tailwindExamplesEntries) {
    const name = entry.name.replace(FILE_EXTENSION_REGEX, "");
    const isFile = entry.isFile();
    const componentPath = isFile
      ? `@/registry/brook/tailwind/examples/${name}`
      : `@/registry/brook/tailwind/examples/${name}/${name}`;

    const files = await getComponentFiles(tailwindExamplesDir, entry.name);
    const filesArray = files.length > 0 ? `["${files.join('", "')}"]` : "[]";
    const key = name.includes("-") ? `"${name}-tailwind"` : `${name}Tailwind`;

    // Metadata
    metadataIndex += `
  ${key}: {
    name: "${name}-tailwind",
    type: "example",
    files: ${filesArray},
    path: "${componentPath}",
  },`;

    // Loader
    const importStatement =
      componentPath.length > MAX_IMPORT_LINE_LENGTH
        ? `const mod = await import(
        "${componentPath}"
      );`
        : `const mod = await import("${componentPath}");`;

    loadersIndex += `
  ${key}: lazy(async () => {
    ${importStatement}
    const exportName =
      Object.keys(mod).find(
        (key) =>
          typeof mod[key] === "function" || typeof mod[key] === "object"
      ) || "${name}";
    return { default: mod.default || mod[exportName] };
  }),`;
  }

  // Process tailwind blocks
  for (const entry of tailwindBlocksEntries) {
    const name = entry.name.replace(FILE_EXTENSION_REGEX, "");
    const isFile = entry.isFile();
    const componentPath = isFile
      ? `@/registry/brook/tailwind/blocks/${name}`
      : `@/registry/brook/tailwind/blocks/${name}/${name}`;

    const files = await getComponentFiles(tailwindBlocksDir, entry.name);
    const filesArray = files.length > 0 ? `["${files.join('", "')}"]` : "[]";
    const key = name.includes("-") ? `"${name}-tailwind"` : `${name}Tailwind`;

    // Metadata
    metadataIndex += `
  ${key}: {
    name: "${name}-tailwind",
    type: "block",
    files: ${filesArray},
    path: "${componentPath}",
  },`;

    // Loader
    const importStatement =
      componentPath.length > MAX_IMPORT_LINE_LENGTH
        ? `const mod = await import(
        "${componentPath}"
      );`
        : `const mod = await import("${componentPath}");`;

    loadersIndex += `
  ${key}: lazy(async () => {
    ${importStatement}
    const exportName =
      Object.keys(mod).find(
        (key) =>
          typeof mod[key] === "function" || typeof mod[key] === "object"
      ) || "${name}";
    return { default: mod.default || mod[exportName] };
  }),`;
  }

  // Process tailwind UI components
  for (const entry of tailwindUiEntries) {
    const name = entry.name.replace(FILE_EXTENSION_REGEX, "");
    const files = await getComponentFiles(tailwindUiDir, entry.name);

    if (files.length === 0) continue;

    const filesArray = `["${files.join('", "')}"]`;
    const key = name.includes("-") ? `"${name}-tailwind"` : `${name}Tailwind`;

    metadataIndex += `
  ${key}: {
    name: "${name}-tailwind",
    type: "ui",
    files: ${filesArray},
  },`;
  }

  metadataIndex += `
};
`;

  loadersIndex += `
};
`;

  console.log(`✅ ${examplesEntries.length} examples found`);
  console.log(`✅ ${blocksEntries.length} blocks found`);
  console.log(`✅ ${uiEntries.length} ui components found`);
  console.log(`✅ ${tailwindExamplesEntries.length} tailwind examples found`);
  console.log(`✅ ${tailwindBlocksEntries.length} tailwind blocks found`);
  console.log(`✅ ${tailwindUiEntries.length} tailwind ui components found`);

  // Write metadata index (lightweight)
  const metadataOutputPath = path.join(process.cwd(), "registry/__index__.tsx");
  await fs.mkdir(path.dirname(metadataOutputPath), { recursive: true });
  await fs.writeFile(metadataOutputPath, metadataIndex);
  console.log("✅ Built registry/__index__.tsx (metadata only)");

  // Write component loaders (separate file, loaded on-demand)
  const loadersOutputPath = path.join(process.cwd(), "registry/__loaders__.tsx");
  await fs.writeFile(loadersOutputPath, loadersIndex);
  console.log("✅ Built registry/__loaders__.tsx (components)");

  // Format the generated files
  const { execSync } = await import("node:child_process");
  try {
    execSync("pnpm lint:fix registry/__index__.tsx registry/__loaders__.tsx", {
      stdio: "inherit",
    });
    console.log("✅ Formatted registry files");
  } catch (_error) {
    console.warn("⚠️  Could not format files, but continuing...");
  }
}

buildOptimizedRegistry().catch((error) => {
  console.error(error);
  process.exit(1);
});
