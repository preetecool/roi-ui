import type { Dirent } from "node:fs";
import { promises as fs } from "node:fs";
import path from "node:path";

const FILE_EXTENSION_REGEX = /\.(tsx?|jsx?)$/;
const MAX_IMPORT_LINE_LENGTH = 44; // Keep import statements under 80 chars total

/**
 * Get all files in a directory (tsx and css)
 */
async function getComponentFiles(dir: string, name: string): Promise<string[]> {
  const files: string[] = [];
  const basePath = path.join(dir, name);
  const cwd = process.cwd();

  try {
    // Check if it's a directory
    const stat = await fs.stat(basePath);
    if (stat.isDirectory()) {
      const dirFiles = await fs.readdir(basePath);
      for (const file of dirFiles) {
        if (file.endsWith('.tsx') || file.endsWith('.module.css')) {
          const fullPath = path.join(basePath, file);
          files.push(path.relative(cwd, fullPath));
        }
      }
    } else {
      // It's a file
      files.push(path.relative(cwd, basePath));
    }
  } catch {
    // Try as a direct file
    try {
      const tsxPath = `${basePath}.tsx`;
      await fs.stat(tsxPath);
      files.push(path.relative(cwd, tsxPath));
    } catch {
      // Doesn't exist
    }
  }

  return files;
}

// biome-ignore lint/complexity/noExcessiveCognitiveComplexity: Script complexity is acceptable for code generation
async function buildRegistryIndex() {
  const examplesDir = path.join(process.cwd(), "registry/brook/examples");
  const blocksDir = path.join(process.cwd(), "registry/brook/blocks");
  const uiDir = path.join(process.cwd(), "registry/brook/ui");
  const tailwindExamplesDir = path.join(process.cwd(), "registry/brook/tailwind/examples");
  const tailwindBlocksDir = path.join(process.cwd(), "registry/brook/tailwind/blocks");
  const tailwindUiDir = path.join(process.cwd(), "registry/brook/tailwind/ui");

  const examplesEntries = await fs.readdir(examplesDir, {
    withFileTypes: true,
  });

  let blocksEntries: Dirent[] = [];
  try {
    blocksEntries = await fs.readdir(blocksDir, { withFileTypes: true });
  } catch {
    // blocks directory might not exist
  }

  let uiEntries: Dirent[] = [];
  try {
    uiEntries = await fs.readdir(uiDir, { withFileTypes: true });
  } catch {
    // ui directory might not exist
  }

  let tailwindExamplesEntries: Dirent[] = [];
  try {
    tailwindExamplesEntries = await fs.readdir(tailwindExamplesDir, { withFileTypes: true });
  } catch {
    // tailwind examples directory might not exist
  }

  let tailwindBlocksEntries: Dirent[] = [];
  try {
    tailwindBlocksEntries = await fs.readdir(tailwindBlocksDir, { withFileTypes: true });
  } catch {
    // tailwind blocks directory might not exist
  }

  let tailwindUiEntries: Dirent[] = [];
  try {
    tailwindUiEntries = await fs.readdir(tailwindUiDir, { withFileTypes: true });
  } catch {
    // tailwind ui directory might not exist
  }

  let index = `// @generated
// This file is autogenerated by scripts/build-registry-index.ts
// Do not edit this file directly.
// @ts-nocheck
import type { ComponentType } from "react";
import { lazy } from "react";

type RegistryEntry = {
  name: string;
  type: "example" | "block" | "ui";
  component?: ComponentType;
  files?: string[];
};

export const Index: Record<string, RegistryEntry> = {`;

  // Process examples
  for (const entry of examplesEntries) {
    const name = entry.name.replace(FILE_EXTENSION_REGEX, "");

    // Check if it's a file or folder
    const isFile = entry.isFile();
    const componentPath = isFile
      ? `@/registry/brook/examples/${name}`
      : `@/registry/brook/examples/${name}/${name}`;

    const files = await getComponentFiles(examplesDir, entry.name);
    const filesArray = files.length > 0 ? `["${files.join('", "')}"]` : "[]";

    // Split long paths for better formatting (keep under 80 chars total line length)
    // Account for: "      const mod = await import(\"...\");" = ~32 chars + path length
    const importStatement =
      componentPath.length > MAX_IMPORT_LINE_LENGTH
        ? `const mod = await import(
        "${componentPath}"
      );`
        : `const mod = await import("${componentPath}");`;

    // Only quote keys if they contain hyphens
    const key = name.includes("-") ? `"${name}"` : name;

    index += `
  ${key}: {
    name: "${name}",
    type: "example",
    files: ${filesArray},
    component: lazy(async () => {
      ${importStatement}
      const exportName =
        Object.keys(mod).find(
          (key) =>
            typeof mod[key] === "function" || typeof mod[key] === "object"
        ) || "${name}";
      return { default: mod.default || mod[exportName] };
    }),
  },`;
  }

  // Process blocks
  for (const entry of blocksEntries) {
    const name = entry.name.replace(FILE_EXTENSION_REGEX, "");

    // Check if it's a file or folder
    const isFile = entry.isFile();
    const componentPath = isFile
      ? `@/registry/brook/blocks/${name}`
      : `@/registry/brook/blocks/${name}/${name}`;

    const files = await getComponentFiles(blocksDir, entry.name);
    const filesArray = files.length > 0 ? `["${files.join('", "')}"]` : "[]";

    // Split long paths for better formatting (keep under 80 chars total line length)
    // Account for: "      const mod = await import(\"...\");" = ~32 chars + path length
    const importStatement =
      componentPath.length > MAX_IMPORT_LINE_LENGTH
        ? `const mod = await import(
        "${componentPath}"
      );`
        : `const mod = await import("${componentPath}");`;

    // Only quote keys if they contain hyphens
    const key = name.includes("-") ? `"${name}"` : name;

    index += `
  ${key}: {
    name: "${name}",
    type: "block",
    files: ${filesArray},
    component: lazy(async () => {
      ${importStatement}
      const exportName =
        Object.keys(mod).find(
          (key) =>
            typeof mod[key] === "function" || typeof mod[key] === "object"
        ) || "${name}";
      return { default: mod.default || mod[exportName] };
    }),
  },`;
  }

  // Process UI components (no runtime component, just file paths)
  for (const entry of uiEntries) {
    const name = entry.name;
    const files = await getComponentFiles(uiDir, name);

    if (files.length === 0) continue;

    const filesArray = `["${files.join('", "')}"]`;
    const key = name.includes("-") ? `"${name}"` : name;

    index += `
  ${key}: {
    name: "${name}",
    type: "ui",
    files: ${filesArray},
  },`;
  }

  // Process tailwind examples
  for (const entry of tailwindExamplesEntries) {
    const name = entry.name.replace(FILE_EXTENSION_REGEX, "");

    // Check if it's a file or folder
    const isFile = entry.isFile();
    const componentPath = isFile
      ? `@/registry/brook/tailwind/examples/${name}`
      : `@/registry/brook/tailwind/examples/${name}/${name}`;

    const files = await getComponentFiles(tailwindExamplesDir, entry.name);
    const filesArray = files.length > 0 ? `["${files.join('", "')}"]` : "[]";

    // Split long paths for better formatting
    const importStatement =
      componentPath.length > MAX_IMPORT_LINE_LENGTH
        ? `const mod = await import(
        "${componentPath}"
      );`
        : `const mod = await import("${componentPath}");`;

    // Only quote keys if they contain hyphens
    const key = name.includes("-") ? `"${name}-tailwind"` : `${name}Tailwind`;

    index += `
  ${key}: {
    name: "${name}-tailwind",
    type: "example",
    files: ${filesArray},
    component: lazy(async () => {
      ${importStatement}
      const exportName =
        Object.keys(mod).find(
          (key) =>
            typeof mod[key] === "function" || typeof mod[key] === "object"
        ) || "${name}";
      return { default: mod.default || mod[exportName] };
    }),
  },`;
  }

  // Process tailwind blocks
  for (const entry of tailwindBlocksEntries) {
    const name = entry.name.replace(FILE_EXTENSION_REGEX, "");

    // Check if it's a file or folder
    const isFile = entry.isFile();
    const componentPath = isFile
      ? `@/registry/brook/tailwind/blocks/${name}`
      : `@/registry/brook/tailwind/blocks/${name}/${name}`;

    const files = await getComponentFiles(tailwindBlocksDir, entry.name);
    const filesArray = files.length > 0 ? `["${files.join('", "')}"]` : "[]";

    // Split long paths for better formatting
    const importStatement =
      componentPath.length > MAX_IMPORT_LINE_LENGTH
        ? `const mod = await import(
        "${componentPath}"
      );`
        : `const mod = await import("${componentPath}");`;

    // Only quote keys if they contain hyphens
    const key = name.includes("-") ? `"${name}-tailwind"` : `${name}Tailwind`;

    index += `
  ${key}: {
    name: "${name}-tailwind",
    type: "block",
    files: ${filesArray},
    component: lazy(async () => {
      ${importStatement}
      const exportName =
        Object.keys(mod).find(
          (key) =>
            typeof mod[key] === "function" || typeof mod[key] === "object"
        ) || "${name}";
      return { default: mod.default || mod[exportName] };
    }),
  },`;
  }

  // Process tailwind UI components (no runtime component, just file paths)
  for (const entry of tailwindUiEntries) {
    const name = entry.name.replace(FILE_EXTENSION_REGEX, "");
    const files = await getComponentFiles(tailwindUiDir, entry.name);

    if (files.length === 0) continue;

    const filesArray = `["${files.join('", "')}"]`;
    const key = name.includes("-") ? `"${name}-tailwind"` : `${name}Tailwind`;

    index += `
  ${key}: {
    name: "${name}-tailwind",
    type: "ui",
    files: ${filesArray},
  },`;
  }

  index += `
}
`;

  console.log(`✅ ${examplesEntries.length} examples found`);
  console.log(`✅ ${blocksEntries.length} blocks found`);
  console.log(`✅ ${uiEntries.length} ui components found`);
  console.log(`✅ ${tailwindExamplesEntries.length} tailwind examples found`);
  console.log(`✅ ${tailwindBlocksEntries.length} tailwind blocks found`);
  console.log(`✅ ${tailwindUiEntries.length} tailwind ui components found`);

  // Write index file
  const outputPath = path.join(process.cwd(), "registry/__index__.tsx");
  await fs.mkdir(path.dirname(outputPath), { recursive: true });
  await fs.writeFile(outputPath, index);

  console.log("✅ Built registry/__index__.tsx");

  // Format the generated file
  const { execSync } = await import("node:child_process");
  try {
    execSync("pnpm lint:fix registry/__index__.tsx", { stdio: "inherit" });
    console.log("✅ Formatted registry/__index__.tsx");
  } catch (_error) {
    console.warn("⚠️  Could not format file, but continuing...");
  }
}

buildRegistryIndex().catch((error) => {
  console.error(error);
  process.exit(1);
});
