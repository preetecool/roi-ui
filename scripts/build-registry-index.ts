import type { Dirent } from "node:fs";
import { promises as fs } from "node:fs";
import path from "node:path";

const FILE_EXTENSION_REGEX = /\.(tsx?|jsx?)$/;
const MAX_IMPORT_LINE_LENGTH = 44; // Keep import statements under 80 chars total

// biome-ignore lint/complexity/noExcessiveCognitiveComplexity: Script complexity is acceptable for code generation
async function buildRegistryIndex() {
  const examplesDir = path.join(process.cwd(), "registry/brook/examples");
  const blocksDir = path.join(process.cwd(), "registry/brook/blocks");
  const tailwindExamplesDir = path.join(process.cwd(), "registry/brook/tailwind/examples");
  const tailwindBlocksDir = path.join(process.cwd(), "registry/brook/tailwind/blocks");

  const examplesEntries = await fs.readdir(examplesDir, {
    withFileTypes: true,
  });

  let blocksEntries: Dirent[] = [];
  try {
    blocksEntries = await fs.readdir(blocksDir, { withFileTypes: true });
  } catch {
    // blocks directory might not exist
  }

  let tailwindExamplesEntries: Dirent[] = [];
  try {
    tailwindExamplesEntries = await fs.readdir(tailwindExamplesDir, { withFileTypes: true });
  } catch {
    // tailwind examples directory might not exist
  }

  let tailwindBlocksEntries: Dirent[] = [];
  try {
    tailwindBlocksEntries = await fs.readdir(tailwindBlocksDir, { withFileTypes: true });
  } catch {
    // tailwind blocks directory might not exist
  }

  let index = `// @generated
// This file is autogenerated by scripts/build-registry-index.ts
// Do not edit this file directly.
// @ts-nocheck
import type { ComponentType } from "react";
import { lazy } from "react";

type RegistryEntry = {
  name: string;
  type: "example" | "block";
  component: ComponentType;
};

export const Index: Record<string, RegistryEntry> = {`;

  // Process examples
  for (const entry of examplesEntries) {
    const name = entry.name.replace(FILE_EXTENSION_REGEX, "");

    // Check if it's a file or folder
    const isFile = entry.isFile();
    const componentPath = isFile
      ? `@/registry/brook/examples/${name}`
      : `@/registry/brook/examples/${name}/${name}`;

    // Split long paths for better formatting (keep under 80 chars total line length)
    // Account for: "      const mod = await import(\"...\");" = ~32 chars + path length
    const importStatement =
      componentPath.length > MAX_IMPORT_LINE_LENGTH
        ? `const mod = await import(
        "${componentPath}"
      );`
        : `const mod = await import("${componentPath}");`;

    // Only quote keys if they contain hyphens
    const key = name.includes("-") ? `"${name}"` : name;

    index += `
  ${key}: {
    name: "${name}",
    type: "example",
    component: lazy(async () => {
      ${importStatement}
      const exportName =
        Object.keys(mod).find(
          (key) =>
            typeof mod[key] === "function" || typeof mod[key] === "object"
        ) || "${name}";
      return { default: mod.default || mod[exportName] };
    }),
  },`;
  }

  // Process blocks
  for (const entry of blocksEntries) {
    const name = entry.name.replace(FILE_EXTENSION_REGEX, "");

    // Check if it's a file or folder
    const isFile = entry.isFile();
    const componentPath = isFile
      ? `@/registry/brook/blocks/${name}`
      : `@/registry/brook/blocks/${name}/${name}`;

    // Split long paths for better formatting (keep under 80 chars total line length)
    // Account for: "      const mod = await import(\"...\");" = ~32 chars + path length
    const importStatement =
      componentPath.length > MAX_IMPORT_LINE_LENGTH
        ? `const mod = await import(
        "${componentPath}"
      );`
        : `const mod = await import("${componentPath}");`;

    // Only quote keys if they contain hyphens
    const key = name.includes("-") ? `"${name}"` : name;

    index += `
  ${key}: {
    name: "${name}",
    type: "block",
    component: lazy(async () => {
      ${importStatement}
      const exportName =
        Object.keys(mod).find(
          (key) =>
            typeof mod[key] === "function" || typeof mod[key] === "object"
        ) || "${name}";
      return { default: mod.default || mod[exportName] };
    }),
  },`;
  }

  // Process tailwind examples
  for (const entry of tailwindExamplesEntries) {
    const name = entry.name.replace(FILE_EXTENSION_REGEX, "");

    // Check if it's a file or folder
    const isFile = entry.isFile();
    const componentPath = isFile
      ? `@/registry/brook/tailwind/examples/${name}`
      : `@/registry/brook/tailwind/examples/${name}/${name}`;

    // Split long paths for better formatting
    const importStatement =
      componentPath.length > MAX_IMPORT_LINE_LENGTH
        ? `const mod = await import(
        "${componentPath}"
      );`
        : `const mod = await import("${componentPath}");`;

    // Only quote keys if they contain hyphens
    const key = name.includes("-") ? `"${name}-tailwind"` : `${name}Tailwind`;

    index += `
  ${key}: {
    name: "${name}-tailwind",
    type: "example",
    component: lazy(async () => {
      ${importStatement}
      const exportName =
        Object.keys(mod).find(
          (key) =>
            typeof mod[key] === "function" || typeof mod[key] === "object"
        ) || "${name}";
      return { default: mod.default || mod[exportName] };
    }),
  },`;
  }

  // Process tailwind blocks
  for (const entry of tailwindBlocksEntries) {
    const name = entry.name.replace(FILE_EXTENSION_REGEX, "");

    // Check if it's a file or folder
    const isFile = entry.isFile();
    const componentPath = isFile
      ? `@/registry/brook/tailwind/blocks/${name}`
      : `@/registry/brook/tailwind/blocks/${name}/${name}`;

    // Split long paths for better formatting
    const importStatement =
      componentPath.length > MAX_IMPORT_LINE_LENGTH
        ? `const mod = await import(
        "${componentPath}"
      );`
        : `const mod = await import("${componentPath}");`;

    // Only quote keys if they contain hyphens
    const key = name.includes("-") ? `"${name}-tailwind"` : `${name}Tailwind`;

    index += `
  ${key}: {
    name: "${name}-tailwind",
    type: "block",
    component: lazy(async () => {
      ${importStatement}
      const exportName =
        Object.keys(mod).find(
          (key) =>
            typeof mod[key] === "function" || typeof mod[key] === "object"
        ) || "${name}";
      return { default: mod.default || mod[exportName] };
    }),
  },`;
  }

  index += `
}
`;

  console.log(`✅ ${examplesEntries.length} examples found`);
  console.log(`✅ ${blocksEntries.length} blocks found`);
  console.log(`✅ ${tailwindExamplesEntries.length} tailwind examples found`);
  console.log(`✅ ${tailwindBlocksEntries.length} tailwind blocks found`);

  // Write index file
  const outputPath = path.join(process.cwd(), "registry/__index__.tsx");
  await fs.mkdir(path.dirname(outputPath), { recursive: true });
  await fs.writeFile(outputPath, index);

  console.log("✅ Built registry/__index__.tsx");

  // Format the generated file
  const { execSync } = await import("node:child_process");
  try {
    execSync("pnpm lint:fix registry/__index__.tsx", { stdio: "inherit" });
    console.log("✅ Formatted registry/__index__.tsx");
  } catch (_error) {
    console.warn("⚠️  Could not format file, but continuing...");
  }
}

buildRegistryIndex().catch((error) => {
  console.error(error);
  process.exit(1);
});
